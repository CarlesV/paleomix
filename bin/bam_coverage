#!/usr/bin/python
#
# Copyright (c) 2012 Mikkel Schubert <MSchubert@snm.ku.dk>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
import os
import sys
import getpass
import optparse

import pypeline
import pypeline.ui
import pypeline.logger
import pypeline.common.system

from pypeline.common.console import \
    print_info
from pypeline.nodes.samtools import \
    BAMIndexNode
from pypeline.nodes.coverage import \
    CoverageNode


def _build_option_parser():
    usage = "%prog [options] <file_1.bam> [<file_2.bam>, ...]"
    parser = optparse.OptionParser(usage=usage)

    # Adds --progress-ui; used by the pipeline to select CLI UI
    pypeline.ui.add_optiongroup(parser)
    # Adds --log-level and --log-file; these options are expected by the
    # 'pypeline.logger.initialize' function called in 'main'
    pypeline.logger.add_optiongroup(parser)

    parser.add_option("--target-name", default=None,
                      help="Name used for 'Target' column; defaults to the "
                           "filename of the BAM file.")
    parser.add_option("--regions-file", default=None, dest="regions_fpath",
                      help="BED file containing regions of interest; coverage "
                           "is calculated only for these grouping by the name "
                           "used in the BED file, or the contig name if no "
                           "name has been specified for a record.")

    group = optparse.OptionGroup(parser, "Required paths")
    temp_root = os.path.join("/tmp", getpass.getuser(), "bam_coverage")
    group.add_option("--temp-root", default=temp_root,
                     help="Root folder for temp files/folders [%default].")
    parser.add_option_group(group)

    group = optparse.OptionGroup(parser, "Scheduling")
    group.add_option("--max-threads", type=int, default=1,
                     help="Max files to process concurrently [%default]")
    group.add_option("--dry-run", action="store_true", default=False,
                     help="Only show tasks to perform, do not run.")
    parser.add_option_group(group)

    return parser


def _build_coverage_node(input_fpath, regions_fpath=None,
                         target_name=None):
    if target_name is None:
        target_name = os.path.basename(input_fpath)

    # Coverage for specific regions relies on the use of the Samfile.fetch
    # function, which in turn requires sorted / indexed BAM files; the indexing
    # step will fail if the file is not sorted.
    # FIXME: Only require index when 'regions_fpath' is set.
    dependencies = (BAMIndexNode(input_fpath),)

    return CoverageNode(input_file=input_fpath,
                        intervals_file=regions_fpath,
                        target_name=target_name,
                        dependencies=dependencies)


def main(argv):
    parser = _build_option_parser()
    config, input_fpaths = parser.parse_args(argv)
    if not input_fpaths:
        parser.print_usage()
        return 1

    # Set process name on supported platforms
    pypeline.common.system.set_procname()
    # Log to console only, except if --log-file is specified
    pypeline.logger.initialize(config, None)
    # Config object is passed to nodes during execution
    pipeline = pypeline.Pypeline(config)

    # Duplicate file-names are elimated to prevent the pipeline from
    # complaining about / aborting due to clobbering of files; it is
    # assumed to be a trivial mistake.
    print_info("Building BAM coverage pipeline ...")
    for input_fpath in set(input_fpaths):
        node = _build_coverage_node(input_fpath=input_fpath,
                                    regions_fpath=config.regions_fpath,
                                    target_name=config.target_name)
        pipeline.add_nodes(node)

    print_info("Running BAM coverage pipeline ...")
    if pipeline.run(max_running=config.max_threads,
                    dry_run=config.dry_run,
                    progress_ui=config.progress_ui):
        return 0
    return 1


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
