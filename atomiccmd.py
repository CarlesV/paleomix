import os
import subprocess

import fileutils


class CmdError(RuntimeError):
    def __init__(self, msg):
        RuntimeError.__init__(self, msg)

    

class AtomicCmd:
    """Executes a command, only moving resulting files to the destination
    directory if the command was succesful. This helps prevent the 
    accidential use of partial files in downstream analysis, and eases 
    restarting of a pipeline following errors (no cleanup)."""
    PIPE = subprocess.PIPE

    def __init__(self, destination, command, stdin = None, stdout = None, stderr = None, **kwargs):
        self.proc  = None
        self._cmd  = command
        self._dest = destination
        self._temp = None
        
        # Fill the in_files and out_files dictionaries 
        # in_files = jars, fasta, bams, etc. Prefix = "IN_"
        # out_files = files generated by the command. Prefix = "OUT_"
        self._in_files, self._out_files = {}, {}
        self._group_io_by_prefix(kwargs)

        self._stdin  = stdin
        self._stderr = stderr
        self._stdout = stdout
        self._handles = {}

        if type(stdin) is str:
            self._in_files["PIPE_STDIN"] = stdin
        if type(stdout) is str:
            self._out_files["PIPE_STDOUT"] = stdout
        if (type(stderr) is str) and (stdout != stderr):
            self._out_files["PIPE_STDERR"] = stderr

        self._temp_files = None
        self._final_files = self._generate_filenames(root = destination)


    def run(self, temp):
        """Runs the given command. If temp is specified, that folder 
        will be used to save temporary files, otherwise a new temporary
        folder will be created."""
        stdin  = self._open_pipe(temp, self._stdin , "rb")
        stdout = self._open_pipe(temp, self._stdout, "wb")
        stderr = self._open_pipe(temp, self._stderr, "wb")

        self._temp_files = self._generate_filenames(root = temp)
        
        kwords = dict(self._temp_files)
        kwords.update(self._in_files)

        cmd = [(field % kwords) for field in self._cmd]
        self.proc = subprocess.Popen(cmd, 
                                     stdin  = stdin,
                                     stdout = stdout,
                                     stderr = stderr)       
        self._temp = temp

    def wait(self):
        """Equivalent to Popen.wait(), but returns the value wrapped in a list."""
        return [self.proc.wait()]


    def poll(self):
        """Equivalent to Popen.poll(), but returns the value wrapped in a list."""
        return [self.proc.poll()]


    def missing_input_files(self):
        """Returns a list of input files that are required by the AtomicCmd,
        but which does not currently exist. This list should be empty, 
        otherwise the command is expected to fail."""
        return fileutils.missing_files(self._in_files.itervalues())
        

    def missing_output_files(self, ignore_pipes = False):
        """Checks that the expected output files have been generated. If
        'ignore_pipes' is True, files generated by stdout or stderr
        are ignored."""
        files = self._generate_filenames(root = self._dest, ignore_pipes = ignore_pipes)
        return fileutils.missing_files(files.itervalues())


    def missing_temp_files(self):
        return fileutils.missing_files(self._temp_files.itervalues())


    def commit(self):
        assert (self.poll() is not None)
        assert not self.missing_temp_files()

        # Close any implictly opened pipes
        for (_, handle) in self._handles.itervalues():
            handle.close()

        for key in self._temp_files:
            os.rename(self._temp_files[key], self._final_files[key])

        self.proc = None


    def __str__(self):
        return "<'%s' in '%s'>" % (" ".join(self._cmd), self._temp)


    def _group_io_by_prefix(self, io):
        for (key, value) in io.iteritems():
            if key.startswith("IN_"):
                self._in_files[key] = value
            elif key.startswith("OUT_"):
                self._out_files[key] = value
            else:
                raise CmdError("Command contains unclassified argument: '%s' -> '%s'" \
                                   % (self, key))
        

    def _open_pipe(self, root, pipe, mode):
        if isinstance(pipe, AtomicCmd):
            assert mode == "rb"
            return pipe.proc.stdout
        elif not (type(pipe) is str):
            return pipe
        elif pipe not in self._handles:
            self._handles[pipe] = (mode, open(os.path.join(root, pipe), mode))

        pipe_mode, pipe = self._handles[pipe]
        if pipe_mode != mode:
            raise CmdError("Attempting to open pipe with different modes: '%s' -> '%s'" \
                               % (self, pipe))

        return pipe

    def _generate_filenames(self, root, ignore_pipes = False):
        filenames = {}
        for (key, filename) in self._out_files.iteritems():
            if not (key.startswith("PIPE_") and ignore_pipes):
                filenames[key] = os.path.join(root, filename)
        return filenames



class AtomicSet:
    def __init__(self, commands, threads = 1):
        self._commands = list(commands)

    def run(self, temp):
        for command in self._commands:
            command.run(temp)

    def wait(self):
        return_codes = []
        for command in self._commands:
            return_codes.extend(command.wait())
        return return_codes

    def poll(self):
        return_codes = []
        for command in self._commands:
            return_codes.extend(command.poll())
        return return_codes

    def missing_input_files(self):
        missing_files = []
        for command in self._commands:
            missing_files.extend(command.missing_input_files())
        return missing_files

    def missing_output_files(self, ignore_pipes = False):
        missing_files = []
        for command in self._commands:
            missing_files.extend(command.missing_output_files())
        return missing_files

    def missing_temp_files(self):
        missing_files = []
        for command in self._commands:
            missing_files.extend(command.missing_temp_files())
        return missing_files

    def commit(self):
        for command in self._commands:
            command.commit()

    def __str__(self):
        return "[%s]" % ", ".join(map(str, self._commands))
